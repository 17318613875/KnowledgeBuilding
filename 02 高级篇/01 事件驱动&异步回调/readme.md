# 事件驱动&异步回调

Node采用事件驱动的运行方式的**单线程单进程应用**。

## 事件驱动

事件驱动是建立在事件驱动模型基础之上的。

### 传统线程网络模型

![线程网络模型](../../.source/线程网络模型.png "线程网络模型")

传统线程网络模型：处理任务时会在线程池(Tread Loop)中分配一个线程来**线性同步**完成任务。

### 事件驱动模型

![事件驱动模型](../../.source/事件驱动模型.png "事件驱动模型")

在事件驱动的模型当中，每一个异步工作被添加到**事件队列**中，**主循环线程**循环地处理队列上的工作任务，当执行过程中遇到来堵塞(读取文件、查询数据库)任务时，主循环线程不会停下来等待结果，而是留下一个处理结果的回调函数，转而继续执行队列中的下一个任务。
这个传递到队列中的回调函数在堵塞任务运行结束后才被线程调用。

## 阻塞/非阻塞

传统线程网络模型是阻塞的，弊端:

1. 线程池中线程个数有限，容易出现新任务请求的等待，严重会宕机;
2. 为保障数据的准确性，事务&锁造成等待，导致线程占用资源，效能低下。

事件驱动模型是非阻塞的

1. 采用事件回调使主线程避开堆阻塞线程的等待;
2. 阻塞任务，在线程池获取一个线程，将阻塞任务在此执行，形成等待线程，并将回调函数添加到事件队列中。

![非阻塞机制](../../.source/非阻塞机制.png "非阻塞机制")

## 阻塞/非阻塞|异步/同步|并发/并行

项目    |区别
--------|-------
阻塞    |线程操作采用线性网络模型，当前线程操作的数据未就绪，当前与后续线程需等待
非阻塞  |线程操作采用事件驱动模型，主线程操作轮询任务队列，当前与否需任务无需等待
同步    |任务必须一件一件依次的执行，下一任务需等待上一任务执行完毕，**同步不代表阻塞，但阻塞肯定是同步**
异步    |任务无需依次执行
并发    |当有多个线程在操作时，如果系统只有一个CPU，操作系统只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的快速的切换不同的线程代码运行
并行    |当系统有多个CPU时，可以存在当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行
